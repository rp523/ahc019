# 検討メモ

## 考えたこと
使用ブロックを余らせないようにする調整は最後にやる。  
また、最終的には1x1x1のブロックを使うようなプログラムは順位表から淘汰されそうな気がするので、  
最低限2x1x1は精一杯つなげたほうがいいだろう。  
また、必要以上のブロックを使ったとしても、それらの連結数が少なければペナルティにはならない。  

## 処理内容
まずは最大流で2x1x1単位のブロックを限界まで敷き詰める。  
シルエットが完成していなかったら、しぶしぶ1x1x1を入れる。でもそんなにやらなくていいはず。  
繋げられる限りつなく。1x1x1から優先的につなげる。←2x1x1からのほうがいいのでは？実際には最大流だから制御できないけど  
 - それぞれのシルエットごとに、存在するブロック番号を２重ループで全探索しIDペアを列挙する。  
 - ビットフィールドがいいと思うが、ブロックの原点ベースで専有位置メモを生成する。ついでにIDペアの接続判定もやる。
 - 3次元回転の全パターンを試して、重複するものがあるか探していく。

つなぎきれなかったブロックで、消してもシルエットが変わらないものは削除する。

最終的には焼きなましを使うことになるだろうけど、スコア関数が非線形すぎて、そんなにうまくいかない気がする。
良い初期値をある程度貪欲に作ることを１週目は頑張りたい。
最大流使ったらなんとかならんかな

スコア関数がめちゃめちゃ非線形ぽいから、良い初期値を最大流で求める方式で進める。  
現状のやり方でのワーストスコアケースを見ると、やたらシルエット同士でマッチングしない余りがある。
余らせないようにマッチングさせる方針が必要ぽい。
あとDが大きい場合には最大流どころか事前のマージマッチング自体全然回数回ってない。

一度高速化やったほうがいいかもしれない  <- IDフィールド実体ではなくループ軸方向を回転させることで爆速に。これで焼ける
最後は最大重みマッチングやりたい  <- ダイクストラがやれるようにオフセット入れて正のコストにしたけどだめ。たぶん、共通ブロックにもコストが存在するせい。
孤立してても分割すればマッチさせられそうなのがある  <- まずは焼きなましでやる
最後の孤立削除に優先度をつける <- 微増。かなり貪欲にやってもいいと思う

簡単な焼きなましをやってみたが、ベストスコア更新回数が非常に少ない。  
しかも最初頻繁に状態更新されるくらいでほとんど状態変化がない。  
状態をもっとドラスティックに変える必要がある。そしてできれば良い遷移を見つけたい…

modifyをdestructiveにして、Stateのrefineを毎回やることでかなりスコアアップ。  
これで山登りじゃなくて焼きなましによる効果が見込める。  
remove_uselessで捨ててしまっている可能性を拾い上げて状態遷移させたい。  
マージ消してペア同士で回転マッチングさせる高速化の恩恵がもうちょっとありそう。  
